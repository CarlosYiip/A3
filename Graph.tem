/************************************************* Graph **************************************************/
template <typename N, typename E>
bool Graph<N, E>::addNode(const N &val) {

    auto it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::shared_ptr<Node> &sp) {
    	return sp->get_data() == val;
    });

    if (it != nodes_sp.cend())
    	return false;

    std::shared_ptr<Node> new_node_sp = std::make_shared<Node>(val);
    nodes_sp.push_back(new_node_sp);
    
    return true;
}

template <typename N, typename E>
bool Graph<N, E>::addEdge(const N &src, const N &dst, const E &w) {
	auto edge_it = std::find_if(edges.cbegin(), edges.cend(), [&] (const Edge &edge) {
		bool b1 = edge.get_src_data() == src;
		bool b2 = edge.get_dst_data() == dst;
		bool b3 = edge.get_weight() == w;
		return b1 && b2 && b3;
	});

	if (edge_it != edges.cend())
		return false;

    auto src_it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::shared_ptr<Node> &sp) {
        return sp->get_data() == src;
    });

    auto dst_it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::shared_ptr<Node> &sp) {
        return sp->get_data() == dst;
    });

    if (src_it == nodes_sp.cend() || dst_it == nodes_sp.cend())
        throw std::runtime_error("either src or dst not in graph");

    (*src_it)->inc_out_degree();
    (*dst_it)->inc_in_degree(); 
    Edge new_edge{*src_it, *dst_it, w};
    edges.push_back(new_edge);

    return true;
};

template <typename N, typename E>
bool Graph<N, E>::replace(const N &old_data, const N &new_data) {
	auto old_it = std::find_if(nodes_sp.begin(), nodes_sp.end(), [&] (std::shared_ptr<Node> &sp) {
		return sp->get_data() == old_data;
	});

	if (old_it == nodes_sp.end())
		throw std::runtime_error("old node not in the graph");

	auto new_it = std::find_if(nodes_sp.begin(), nodes_sp.end(), [&] (std::shared_ptr<Node> &sp) {
		return sp->get_data() == new_data;
	});

	if (new_it != nodes_sp.end())
		return false;

	(*old_it)->set_data(new_data);
	return true;
}

template <typename N, typename E>
void Graph<N, E>::mergeReplace(const N &old_data, const N &new_data) {
	auto old_it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::shared_ptr<Node> &sp) {
		return sp->get_data() == old_data;
	});

	auto new_it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::shared_ptr<Node> &sp) {
		return sp->get_data() == new_data;
	});

	if (old_it == nodes_sp.end() || new_it == nodes_sp.cend())
		throw std::runtime_error("either old node or new node is not in the graph");

	std::for_each(edges.begin(), edges.end(), [&] (Edge &edge){
		if (edge.get_dst_data() == old_data)
			edge.set_src_node(*new_it);
	});

	// Left for the remove dulicate edges part. 
	// std::sort(edges.begin(), edges.end());

	nodes_sp.erase(old_it);
}


template <typename N, typename E>
void Graph<N, E>::deleteNode(const N& d) noexcept {
	auto it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::shared_ptr<Node>& sp) {
		return sp->get_data() == d;
	});

	if (it != nodes_sp.end())
		nodes_sp.erase(it);
}

template <typename N, typename E>
void Graph<N, E>::deleteEdge(const N& src, const N& dst, const E& w) noexcept {
	auto it = std::find_if(edges.cbegin(), edges.cend(), [&] (const Edge& edge) {
		bool b1 = edge.get_src_data() == src;
		bool b2 = edge.get_dst_data() == dst;
		bool b3 = edge.get_weight() == w;
		return b1 && b2 && b3;
	});

	if (it != edges.end()) {
		edges.erase(it);
	}
}


template <typename N, typename E>
void Graph<N, E>::clear() noexcept {
	nodes_sp.clear();
	edges.clear();
}

template <typename N, typename E>
bool Graph<N, E>::isNode(const N& val) const {
	auto it = std::find_if(nodes_sp.cbegin(), nodes_sp.cend(), [&] (const std::vector<Node> &sp) {
		return sp->get_data() == val;
	});

	return it != nodes_sp.cend();
}

template <typename N, typename E>
bool Graph<N, E>::isConnected(const N &src, const N &dst) const {
	if (!isNode(src) || !(isNode(dst)))
		throw std::runtime_error("either src node or dst node is not in the graph");

	auto it = std::find_if(edges.cbegin(), edges.cend(), [&] (const Edge& edge) {
		bool b1 = edge.get_src_data() == src;
		bool b2 = edge.get_dst_data() == dst;
		return b1 && b2;
	}); 

	return it != edges.cend();
}

/************************************************* Node **************************************************/

template <typename N, typename E>
Graph<N, E>::Node::Node(const N &val) : data_ptr{std::make_unique<N>(val)} {};

template <typename N, typename E>
const N &Graph<N, E>::Node::get_data() const { return *data_ptr; };

template <typename N, typename E>
void Graph<N, E>::Node::set_data(const N &new_data) { data_ptr = std::make_unique<N>(new_data); };

template <typename N, typename E>
unsigned Graph<N, E>::Node::get_in_degree() const { return in_degree; };

template <typename N, typename E>
unsigned Graph<N, E>::Node::get_out_degree() const { return out_degree; };

template <typename N, typename E>
void Graph<N, E>::Node::inc_in_degree() { ++in_degree; };

template <typename N, typename E>
void Graph<N, E>::Node::inc_out_degree() { ++out_degree; };

template <typename N, typename E>
void Graph<N, E>::Node::dec_in_degree() { --in_degree; };

template <typename N, typename E>
void Graph<N, E>::Node::dec_out_degree() { --out_degree; };

template <typename N, typename E>
void Graph<N, E>::Node::set_in_degree(unsigned n) { in_degree = n; };

template <typename N, typename E>
void Graph<N, E>::Node::set_out_degree(unsigned n) { out_degree = n; };






/************************************************* Edge **************************************************/



template <typename N, typename E>
Graph<N, E>::Edge::Edge(const std::shared_ptr<Node> &src, const std::shared_ptr<Node> &dst, const E &w) : src_ptr{src}, dst_ptr{dst}, weight{w} {}

template <typename N, typename E>
const N& Graph<N, E>::Edge::get_src_data() const { return src_ptr.lock()->get_data(); }

template <typename N, typename E>
const N& Graph<N, E>::Edge::get_dst_data() const { return dst_ptr.lock()->get_data(); }

template <typename N, typename E>
const E& Graph<N, E>::Edge::get_weight() const {return weight; }

template <typename N, typename E>
void Graph<N, E>::Edge::set_src_node(const std::shared_ptr<Node> &src) { src_ptr = src; }

template <typename N, typename E>
void Graph<N, E>::Edge::set_dst_node(const std::shared_ptr<Node> &dst) { dst_ptr = dst; }

// template <typename N, typename E>
// const std::weak_ptr<Graph<N, E>::Node>& Graph<N, E>::Edge::get_src_ptr() const { return src_ptr; }

// template <typename N, typename E>
// const std::weak_ptr<Node>& Graph<N, E>::Edge::get_dst_ptr() const { return dst_ptr; }














